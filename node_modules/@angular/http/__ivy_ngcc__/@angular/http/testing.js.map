{"version":3,"file":"testing.js","sources":["../../../../../packages/http/testing/src/mock_backend.ts","../../../../../packages/http/testing/src/testing.ts","../../../../../packages/http/testing/public_api.ts","../../../../../packages/http/testing/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable} from '@angular/core';\nimport {Connection, ConnectionBackend, ReadyState, Request, Response} from '@angular/http';\nimport {ReplaySubject} from 'rxjs/ReplaySubject';\nimport {Subject} from 'rxjs/Subject';\nimport {take} from 'rxjs/operator/take';\n/**\n * \n * Mock Connection to represent a {\\@link Connection} for tests.\n * \n * \\@experimental\n */\nexport class MockConnection implements Connection {\n/**\n * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n * additional states. For example, state 5 indicates an aborted connection.\n */\nreadyState: ReadyState;\n/**\n * {\\@link Request} instance used to create the connection.\n */\nrequest: Request;\n/**\n * {\\@link EventEmitter} of {\\@link Response}. Can be subscribed to in order to be notified when a\n * response is available.\n */\nresponse: ReplaySubject<Response>;\n/**\n * @param {?} req\n */\nconstructor(req: Request) {\n    this.response = <any>take.call(new ReplaySubject(1), 1);\n    this.readyState = ReadyState.Open;\n    this.request = req;\n  }\n/**\n * Sends a mock response to the connection. This response is the value that is emitted to the\n * {\\@link EventEmitter} returned by {\\@link Http}.\n * \n * ### Example\n * \n * ```\n * var connection;\n * backend.connections.subscribe(c => connection = c);\n * http.request('data.json').subscribe(res => console.log(res.text()));\n * connection.mockRespond(new Response(new ResponseOptions({ body: 'fake response' }))); //logs\n * 'fake response'\n * ```\n * \n * @param {?} res\n * @return {?}\n */\nmockRespond(res: Response) {\n    if (this.readyState === ReadyState.Done || this.readyState === ReadyState.Cancelled) {\n      throw new Error('Connection has already been resolved');\n    }\n    this.readyState = ReadyState.Done;\n    this.response.next(res);\n    this.response.complete();\n  }\n/**\n * Not yet implemented!\n * \n * Sends the provided {\\@link Response} to the `downloadObserver` of the `Request`\n * associated with this connection.\n * @param {?} res\n * @return {?}\n */\nmockDownload(res: Response) {\n    // this.request.downloadObserver.onNext(res);\n    // if (res.bytesLoaded === res.totalBytes) {\n    //   this.request.downloadObserver.onCompleted();\n    // }\n  }\n/**\n * Emits the provided error object as an error to the {\\@link Response} {\\@link EventEmitter}\n * returned\n * from {\\@link Http}.\n * \n * ### Example\n * \n * ```\n * var connection;\n * backend.connections.subscribe(c => connection = c);\n * http.request('data.json').subscribe(res => res, err => console.log(err)));\n * connection.mockError(new Error('error'));\n * ```\n * \n * @param {?=} err\n * @return {?}\n */\nmockError(err?: Error) {\n    // Matches ResourceLoader semantics\n    this.readyState = ReadyState.Done;\n    this.response.error(err);\n  }\n}\n\nfunction MockConnection_tsickle_Closure_declarations() {\n/**\n * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n * additional states. For example, state 5 indicates an aborted connection.\n * @type {?}\n */\nMockConnection.prototype.readyState;\n/**\n * {\\@link Request} instance used to create the connection.\n * @type {?}\n */\nMockConnection.prototype.request;\n/**\n * {\\@link EventEmitter} of {\\@link Response}. Can be subscribed to in order to be notified when a\n * response is available.\n * @type {?}\n */\nMockConnection.prototype.response;\n}\n\n/**\n * A mock backend for testing the {\\@link Http} service.\n * \n * This class can be injected in tests, and should be used to override providers\n * to other backends, such as {\\@link XHRBackend}.\n * \n * ### Example\n * \n * ```\n * import {Injectable, ReflectiveInjector} from '\\@angular/core';\n * import {async, fakeAsync, tick} from '\\@angular/core/testing';\n * import {BaseRequestOptions, ConnectionBackend, Http, RequestOptions} from '\\@angular/http';\n * import {Response, ResponseOptions} from '\\@angular/http';\n * import {MockBackend, MockConnection} from '\\@angular/http/testing';\n * \n * const HERO_ONE = 'HeroNrOne';\n * const HERO_TWO = 'WillBeAlwaysTheSecond';\n * \n * \\@Injectable() \n * class HeroService {\n *   constructor(private http: Http) {}\n * \n *   getHeroes(): Promise<String[]> {\n *     return this.http.get('myservices.de/api/heroes')\n *         .toPromise()\n *         .then(response => response.json().data)\n *         .catch(e => this.handleError(e));\n *   }\n * \n *   private handleError(error: any): Promise<any> {\n *     console.error('An error occurred', error);\n *     return Promise.reject(error.message || error);\n *   }\n * }\n * \n * describe('MockBackend HeroService Example', () => {\n *   beforeEach(() => {\n *     this.injector = ReflectiveInjector.resolveAndCreate([\n *       {provide: ConnectionBackend, useClass: MockBackend},\n *       {provide: RequestOptions, useClass: BaseRequestOptions},\n *       Http,\n *       HeroService,\n *     ]);\n *     this.heroService = this.injector.get(HeroService);\n *     this.backend = this.injector.get(ConnectionBackend) as MockBackend;\n *     this.backend.connections.subscribe((connection: any) => this.lastConnection = connection);\n *   });\n * \n *   it('getHeroes() should query current service url', () => {\n *     this.heroService.getHeroes();\n *     expect(this.lastConnection).toBeDefined('no http service connection at all?');\n *     expect(this.lastConnection.request.url).toMatch(/api\\/heroes$/, 'url invalid');\n *   });\n * \n *   it('getHeroes() should return some heroes', fakeAsync(() => {\n *        let result: String[];\n *        this.heroService.getHeroes().then((heroes: String[]) => result = heroes);\n *        this.lastConnection.mockRespond(new Response(new ResponseOptions({\n *          body: JSON.stringify({data: [HERO_ONE, HERO_TWO]}),\n *        })));\n *        tick();\n *        expect(result.length).toEqual(2, 'should contain given amount of heroes');\n *        expect(result[0]).toEqual(HERO_ONE, ' HERO_ONE should be the first hero');\n *        expect(result[1]).toEqual(HERO_TWO, ' HERO_TWO should be the second hero');\n *      }));\n * \n *   it('getHeroes() while server is down', fakeAsync(() => {\n *        let result: String[];\n *        let catchedError: any;\n *        this.heroService.getHeroes()\n *            .then((heroes: String[]) => result = heroes)\n *            .catch((error: any) => catchedError = error);\n *        this.lastConnection.mockRespond(new Response(new ResponseOptions({\n *          status: 404,\n *          statusText: 'URL not Found',\n *        })));\n *        tick();\n *        expect(result).toBeUndefined();\n *        expect(catchedError).toBeDefined();\n *      }));\n * });\n * ```\n * \n * This method only exists in the mock implementation, not in real Backends.\n * \n * \\@experimental\n */\nexport class MockBackend implements ConnectionBackend {\n/**\n * {\\@link EventEmitter}\n * of {\\@link MockConnection} instances that have been created by this backend. Can be subscribed\n * to in order to respond to connections.\n * \n * ### Example\n * \n * ```\n * import {ReflectiveInjector} from '\\@angular/core';\n * import {fakeAsync, tick} from '\\@angular/core/testing';\n * import {BaseRequestOptions, ConnectionBackend, Http, RequestOptions} from '\\@angular/http';\n * import {Response, ResponseOptions} from '\\@angular/http';\n * import {MockBackend, MockConnection} from '\\@angular/http/testing';\n * \n * it('should get a response', fakeAsync(() => {\n *      let connection:\n *          MockConnection;  // this will be set when a new connection is emitted from the\n *                           // backend.\n *      let text: string;    // this will be set from mock response\n *      let injector = ReflectiveInjector.resolveAndCreate([\n *        {provide: ConnectionBackend, useClass: MockBackend},\n *        {provide: RequestOptions, useClass: BaseRequestOptions},\n *        Http,\n *      ]);\n *      let backend = injector.get(ConnectionBackend);\n *      let http = injector.get(Http);\n *      backend.connections.subscribe((c: MockConnection) => connection = c);\n *      http.request('something.json').toPromise().then((res: any) => text = res.text());\n *      connection.mockRespond(new Response(new ResponseOptions({body: 'Something'})));\n *      tick();\n *      expect(text).toBe('Something');\n *    }));\n * ```\n * \n * This property only exists in the mock implementation, not in real Backends.\n */\nconnections: any;\n/**\n * An array representation of `connections`. This array will be updated with each connection that\n * is created by this backend.\n * \n * This property only exists in the mock implementation, not in real Backends.\n */\nconnectionsArray: MockConnection[];\n/**\n * {\\@link EventEmitter} of {\\@link MockConnection} instances that haven't yet been resolved (i.e.\n * with a `readyState`\n * less than 4). Used internally to verify that no connections are pending via the\n * `verifyNoPendingRequests` method.\n * \n * This property only exists in the mock implementation, not in real Backends.\n */\npendingConnections: any;\nconstructor() {\n    this.connectionsArray = [];\n    this.connections = new Subject();\n    this.connections.subscribe(\n        (connection: MockConnection) => this.connectionsArray.push(connection));\n    this.pendingConnections = new Subject();\n  }\n/**\n * Checks all connections, and raises an exception if any connection has not received a response.\n * \n * This method only exists in the mock implementation, not in real Backends.\n * @return {?}\n */\nverifyNoPendingRequests() {\n    let /** @type {?} */ pending = 0;\n    this.pendingConnections.subscribe((c: MockConnection) => pending++);\n    if (pending > 0) throw new Error(`${pending} pending connections to be resolved`);\n  }\n/**\n * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n * connections, if it's expected that there are connections that have not yet received a response.\n * \n * This method only exists in the mock implementation, not in real Backends.\n * @return {?}\n */\nresolveAllConnections() { this.connections.subscribe((c: MockConnection) => c.readyState = 4); }\n/**\n * Creates a new {\\@link MockConnection}. This is equivalent to calling `new\n * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n * emitter of this `MockBackend` instance. This method will usually only be used by tests\n * against the framework itself, not by end-users.\n * @param {?} req\n * @return {?}\n */\ncreateConnection(req: Request): MockConnection {\n    if (!req || !(req instanceof Request)) {\n      throw new Error(`createConnection requires an instance of Request, got ${req}`);\n    }\n    const /** @type {?} */ connection = new MockConnection(req);\n    this.connections.next(connection);\n    return connection;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction MockBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nMockBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nMockBackend.ctorParameters;\n/**\n * {\\@link EventEmitter}\n * of {\\@link MockConnection} instances that have been created by this backend. Can be subscribed\n * to in order to respond to connections.\n * \n * ### Example\n * \n * ```\n * import {ReflectiveInjector} from '\\@angular/core';\n * import {fakeAsync, tick} from '\\@angular/core/testing';\n * import {BaseRequestOptions, ConnectionBackend, Http, RequestOptions} from '\\@angular/http';\n * import {Response, ResponseOptions} from '\\@angular/http';\n * import {MockBackend, MockConnection} from '\\@angular/http/testing';\n * \n * it('should get a response', fakeAsync(() => {\n *      let connection:\n *          MockConnection;  // this will be set when a new connection is emitted from the\n *                           // backend.\n *      let text: string;    // this will be set from mock response\n *      let injector = ReflectiveInjector.resolveAndCreate([\n *        {provide: ConnectionBackend, useClass: MockBackend},\n *        {provide: RequestOptions, useClass: BaseRequestOptions},\n *        Http,\n *      ]);\n *      let backend = injector.get(ConnectionBackend);\n *      let http = injector.get(Http);\n *      backend.connections.subscribe((c: MockConnection) => connection = c);\n *      http.request('something.json').toPromise().then((res: any) => text = res.text());\n *      connection.mockRespond(new Response(new ResponseOptions({body: 'Something'})));\n *      tick();\n *      expect(text).toBe('Something');\n *    }));\n * ```\n * \n * This property only exists in the mock implementation, not in real Backends.\n * @type {?}\n */\nMockBackend.prototype.connections;\n/**\n * An array representation of `connections`. This array will be updated with each connection that\n * is created by this backend.\n * \n * This property only exists in the mock implementation, not in real Backends.\n * @type {?}\n */\nMockBackend.prototype.connectionsArray;\n/**\n * {\\@link EventEmitter} of {\\@link MockConnection} instances that haven't yet been resolved (i.e.\n * with a `readyState`\n * less than 4). Used internally to verify that no connections are pending via the\n * `verifyNoPendingRequests` method.\n * \n * This property only exists in the mock implementation, not in real Backends.\n * @type {?}\n */\nMockBackend.prototype.pendingConnections;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-server/testing package.\n */\nexport {MockConnection,MockBackend} from './mock_backend';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the http testing package.\n */\nexport {MockConnection,MockBackend} from './src/testing';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport {MockConnection,MockBackend} from './public_api';\n"]}